# static

## static是什么，像什么

像是在一个班级中的学生与班主任的关系。

比如在1班有60个学生，以及1班班主任是张三，一个班只有一个班主任，**类似static修饰的东西全局只存在一个**；而且60个学生的班主任都是同一个班主任，**类似static的全局共享**。

表示1班学生自己班主任是张三，类似**对象.静态成员变量**；表示1班班主任是张三，类似**类名.静态方法**。


## static与无static修饰的变量/类/方法有什么区别

1. 全局只存在一个；
2. 可以被所有人共享访问（类名.静态成员变量）；

## 内存原理

### 修饰成员变量

static修饰**成员变量**内存原理图：
![](https://jam-note-img.oss-cn-hangzhou.aliyuncs.com/leanote-img/4`3GLOH5VHJD@YH{K699$5O.png)
`onLineNumber`是静态变量

#### 术语版：
要获取`onLineNuber`可以直接访问`User`类或者是使用`u1`对象获取

#### 通俗版：
1班学生要想知道班主任的名字直接可以问别的同学，或者是直接看班级班主任名单，是对所有人共享的。

### 修饰成员方法

static修饰**成员方法**内存原理图：
![](https://jam-note-img.oss-cn-hangzhou.aliyuncs.com/leanote-img/20221023141012.png)
`study()`是实例方法
`main()`&`getMax()`是静态方法

#### 术语版：
要想使用`main()`&`getMax()`方法可以直接通过类名进行调用，或是使用该类对象进行调用。而`study()`则是只能通过对象访问，因为这个方法没有使用`static`进行修饰

#### 通俗版：
想要知道1班的班级总排名可以直接看公布出来的班级排名表，或者是问1班的班长。而要与1班的某位学生聊天，则只能找到那个学生才能进行聊天。

## 注意事项

1. 静态方法只能访问静态成员，不能“直接”访问实例成员
2. 实例方法可以访问静态成员，也可以访问实例成员
3. 静态方法中不可以出现`this`关键字

### 为什么？

#### 静态方法为什么不能“直接”访问实例成员，实例方法呢？

因为实例成员在没有实例对象的时候不存在，只有当对象创建时，实例成员才会存在；实例方法也是一样，当对象创建时，实例方法才有意义，脱离对象的实例成员与实例方法没有意义。

#### 为什么实例方法就可以访问静态成员与方法呢？

因为实例方法是建立在对象存在的基础上运行的，当对象存在，那么就可以使用实例成员，又因为静态方法与静态成员均为共享，则依托于对象存在的实例方法便可均可使用。

#### 为什么静态方法中不可以出现`this`关键字呢？

因为`this`关键字是代表使用`this`的对象自身，静态方法可以不用通过对象调用，则当静态方法不用对象调用时使用`this`关键字会造成`this`无意义，故无法使用。

## 用法

### 创建工具类

现在**用户登陆**以及**检验是否为人类**都需要用户输入验证码，为了不在两处重写一段相同逻辑的代码，可创建一个工具类使用`static`修饰内部方法，使用时调用即可。

为什么不用实例方法实现代码功能？
因为实例方法需要创建对象进行调用，而创建对象需要使用内存，不如直接跳过创建对象的过程直接调用静态方法的方式节省内存。

因为不需要使用对象调用工具类方法，所以在此建议将工具类的构造器私有化：

```java
public class Tools {
    private Tools(){}

    public static void test(){}
}
```

### 修饰代码块

当静态资源需要进行初始化时，建议使用静态代码块进行数据初始化。不仅方便调试，也提高了代码可读性，如：

```java
public class Cards {
    public static ArrayList<String> cards = new ArrayList<>();

    static {
        // 准备点数
        String[] sizes = {"2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"};
        // 准备花色
        String[] colors = {"♥️", "♦️", "♠️", "♣️"};
        // 组装添加
        for (int i = 0; i < sizes.length; i++) {
            for (int i1 = 0; i1 < colors.length; i1++) {
                String s = colors[i1] + sizes[i];
                cards.add(s);
            }
        }
        // 添加大小王
        cards.add("joker");
        cards.add("JOKER");
    }
}
```

### 单例设计模式

#### 是什么，像什么，有什么用

这个类永远只有一个实例，即永远只能创建一个对象。
“书同文，车同轨”，全国统一的北京时间，只需要一个时间，用以同步全国的火车高铁。
用以统一标准，或者

#### 如何创建

##### 饿汉单例

特点：直接创建静态对象。

```java
public class SingleInstance {
    // 1。 构造器私有化
    private SingleInstance(){}
    // 2。 在单例内部创建静态对象
    public static SingleInstance si = new SingleInstance();
}
```

##### 懒汉单例

特点：使用静态方法返回静态对象。

```java
public class SingleInstance {
    // 1。 构造器私有化
    private SingleInstance(){}
    // 2。 在单例内部创建对象容器
    private static SingleInstance si;
    // 3。 必须提供一个方法用来返回对象
    public static SingleInstance getInstance() {
        if (si == null) {
            si = new SingleInstance();
        }
        return si;
    }
}
```

###### 相同点

均需要将构造器私有化防止用户调用构造器创建对象。

###### 不同点

饿汉在类内部直接创建单例，方便调用；懒汉首先将对象容器私有化，防止用户使用到无效对象（`null`），再在其内部创建静态方法用来返回单例。

